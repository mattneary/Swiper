{"name":"Swiper","tagline":"A parser DSL for Swift.","body":"# Swiper\r\n\r\nSwiper is a domain-specific language for writing parsers in Swift, taking\r\nadvantage of swift's powerful operator overloading as well as its type system.\r\nSwiper is a work in progress, but here's how it works right now:\r\n\r\n## An Example\r\n\r\n```swift\r\nfunc expr(s : String) -> SResult {\r\n  return swiperTry(\r\n    swiperReturn(s) >>= %\"(\" >>= (expr * %\" \")* * expr >>= %\")\"\r\n  , swiperReturn(s) >>= %\"0\" + %\"1\"\r\n  )\r\n}\r\nswitch expr(\"((0 1 1) (0 1 0))\") {\r\n  case let .Success(m,_): println(m)\r\n  default: println(\"Failure\")\r\n}\r\n// => \"((0 1 1) (0 1 0))\"\r\n```\r\n\r\n## What Remains\r\n\r\nThe key feature not yet in Swiper is the generation of an abstract syntax tree\r\n(AST) which can then be used to evaluate the expression. For now, we are\r\nwaiting for Swift to support recursive `enums`. Once we have this, as well as a\r\nmonad transformer basis rather than the current simple monad, it will work like\r\nthis:\r\n\r\n```swift\r\nenum Expr {\r\n  case Node(String, String)\r\n  case Group(String, [Expr])\r\n}\r\nfunc expr(s : String) -> Expr {\r\n  return swiperTry(\r\n    doo( { \"_\"    <- %\"(\" }\r\n        ,{ \"list\" <- (expr * %\" \")* * expr }\r\n        ,{ \"_\"    <- %\")\" }\r\n        ,{ <<- \"list\" :-: $0(\"list\") })\r\n   ,doo( { \"number\" <- %\"0\" + %\"1\" }\r\n        ,{ <<- \"number\" :: $0(\"number\") })\r\n  )(s)\r\n}\r\nexpr(\"((0 1) (1 1))\")\r\n// => Group(\"list\",\r\n//      [Group(\"list\", [Node(\"number\", \"0\"), Node(\"number\", \"1\")]),\r\n//       Group(\"list\", [Node(\"number\", \"1\"), Node(\"number\", \"1\")])])\r\n```\r\n\r\n## The Parsers\r\n\r\n### String Parsers\r\n\r\n```swift\r\nlet p = %\"abc\"\r\nswitch p(\"abc\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"abc\"\r\n```\r\n\r\n### Sum Parsers\r\n\r\n```swift\r\nlet p = %\"a\" + %\"b\"\r\nswitch p(\"a\") {\r\n  case let .Success(_,_):\r\n    switch p(\"b\") {\r\n      case let .Success(_,_):\r\n        println(\"Both Passed\")\r\n      default: println(\"`b` Failed\")\r\n    }\r\n    default: println(\"`a` Failed\")\r\n}\r\n// -> Both Passed\r\n```\r\n\r\n### Product Parsers\r\n\r\n```swift\r\nlet p = %\"a\" * (%\"b\" + %\"c\")\r\nswitch p(\"ab\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"ab\"\r\n```\r\n\r\n### Power Parsers\r\n\r\n```swift\r\nlet p = (%\"a\")*\r\nswitch p(\"aaa\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"aaa\"\r\n```\r\n\r\n### Recursive Parsers\r\n\r\n```swift\r\nfunc p(s : String) -> SResult {\r\n  return ((%\"a\" * p) + %\"a\")(s)\r\n}\r\nswitch p(\"aaa\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"aaa\"\r\n```\r\n\r\n## Parsing Regular Languages\r\n\r\nThe inductive rules for building a regular language are pretty simple, and the\r\nparsers provided map nicely to the rules. Here are the possible values of a\r\nregular language and how they can be matched with Swiper:\r\n\r\n1. `charParser` matches the singleton `{a}` for some `a` in the alphabet.\r\n2. `A + B` matches expressions matched by `A` and expressions matched by `B`.\r\n3. `A * B` matches the concatenation of expressions matched by `A` and by `B`.\r\n4. `A*` matches members of the Kleene closure of expressions matched by `A`.\r\n\r\n## Combining Parsers\r\n\r\nThere are two special shorthands for combining parsers which will become even\r\nmore useful once parsing begins to return a more structured value than merely\r\nthe matched string. The shorthands are `>>=` for parser products and\r\n`swiperTry(...)` for parser sums. They both work at a different level of\r\nabstraction than the normal `*` and `+` operators.` Here's how they work:\r\n\r\n```swift\r\n// >>= : SResult -> Parser -> SResult\r\n(%\"a\")(\"abc\") >>= %\"b\" == (%\"a\" * %\"b\")(\"abc\")\r\n// swiperTry : (@auto_closure () -> SResult)...\r\nswiperTry( (%\"a\")(\"abc\"), (%\"b\")(\"abc\") ) == (%\"a\" + %\"b\")(\"abc\")\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}