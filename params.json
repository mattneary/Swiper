{"name":"Swiper","tagline":"A parser DSL for Swift.","body":"# Swiper\r\n\r\nSwiper is a domain-specific language for writing parsers in Swift, taking\r\nadvantage of swift's powerful capacity for operator overloading as well as its\r\ntype system. Swiper is a work in progress, but here's how it works right now:\r\n\r\n### String Parsers\r\n\r\n```swift\r\nlet p = %\"abc\"\r\nswitch p(\"abc\") {\r\n  case .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"abc\"\r\n```\r\n\r\n### Sum Parsers\r\n\r\n```swift\r\nlet p = %\"a\" + %\"b\"\r\nswitch p(\"a\") {\r\n  case .Success(_,_):\r\n    switch p(\"b\") {\r\n      case .Success(_,_):\r\n        println(\"Both Passed\")\r\n      default: println(\"`b` Failed\")\r\n    }\r\n    default: println(\"`a` Failed\")\r\n}\r\n// -> Both Passed\r\n```\r\n\r\n### Product Parsers\r\n\r\n```swift\r\nlet p = %\"a\" * (%\"b\" + %\"c\")\r\nswitch p(\"ab\") {\r\n  case .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"ab\"\r\n```\r\n\r\n### Power Parsers\r\n\r\n```swift\r\nlet p = (%\"a\")*\r\nswitch p(\"aaa\") {\r\n  case .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"aaa\"\r\n```\r\n\r\nThese parsers map nicely to the definition of a regular language and are\r\nsufficient for parsing any regular language. However, currently there is\r\nsupport internally for recurvsive expression matching. I will be working to\r\nmake a nice interface for working with these parsers.\r\n\r\n## Parsing Regular Languages\r\n\r\nThe inductive rules for building a regular language are pretty simple, and the\r\nparsers provided map nicely to the rules. Here are the possible values of a\r\nregular language and how they can be matched with Swiper:\r\n\r\n1. `charParser` matches the singleton `{a}` for some `a` in the alphabet.\r\n2. `A + B` matches expressions matched by `A` and expressions matched by `B`.\r\n3. `A * B` matches the concatenation of expressions matched by `A` and by `B`.\r\n4. `A*` matches members of the Kleene closure of expressions matched by `A`.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}