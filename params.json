{"name":"Swiper","tagline":"A parser DSL for Swift.","body":"# Swiper\r\n\r\nSwiper is a domain-specific language for writing parsers in Swift, taking\r\nadvantage of swift's powerful operator overloading as well as its type system.\r\nSwiper is a work in progress, but here's how it works right now:\r\n\r\n## An Example\r\n\r\n```swift\r\nfunc expr(s : String) -> SResult {\r\n  return swiperTry(\r\n    swiperLift(s) >>= %\"(\" >>= (expr * %\" \")* * expr >>= %\")\"\r\n  , swiperLift(s) >>= %\"0\" + %\"1\"\r\n  )\r\n}\r\nswitch expr(\"((0 1 1) (0 1 0))\") {\r\n  case let .Success(_,_): println(\"Success\")\r\n  default: println(\"Failure\")\r\n}\r\n// => Success\r\n```\r\n\r\n## The Parsers\r\n\r\n### String Parsers\r\n\r\n```swift\r\nlet p = %\"abc\"\r\nswitch p(\"abc\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"abc\"\r\n```\r\n\r\n### Sum Parsers\r\n\r\n```swift\r\nlet p = %\"a\" + %\"b\"\r\nswitch p(\"a\") {\r\n  case let .Success(_,_):\r\n    switch p(\"b\") {\r\n      case let .Success(_,_):\r\n        println(\"Both Passed\")\r\n      default: println(\"`b` Failed\")\r\n    }\r\n    default: println(\"`a` Failed\")\r\n}\r\n// -> Both Passed\r\n```\r\n\r\n### Product Parsers\r\n\r\n```swift\r\nlet p = %\"a\" * (%\"b\" + %\"c\")\r\nswitch p(\"ab\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"ab\"\r\n```\r\n\r\n### Power Parsers\r\n\r\n```swift\r\nlet p = (%\"a\")*\r\nswitch p(\"aaa\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"aaa\"\r\n```\r\n\r\n### Recursive Parsers\r\n\r\n```swift\r\nfunc p(s : String) -> SResult {\r\n  return ((%\"a\" * p) + %\"a\")(s)\r\n}\r\nswitch p(\"aaa\") {\r\n  case let .Success(a,r): println(a)\r\n  default: println(\"failed\")\r\n}\r\n// => \"aaa\"\r\n```\r\n\r\n## Parsing Regular Languages\r\n\r\nThe inductive rules for building a regular language are pretty simple, and the\r\nparsers provided map nicely to the rules. Here are the possible values of a\r\nregular language and how they can be matched with Swiper:\r\n\r\n1. `charParser` matches the singleton `{a}` for some `a` in the alphabet.\r\n2. `A + B` matches expressions matched by `A` and expressions matched by `B`.\r\n3. `A * B` matches the concatenation of expressions matched by `A` and by `B`.\r\n4. `A*` matches members of the Kleene closure of expressions matched by `A`.\r\n\r\n## Combining Parsers\r\n\r\nThere are two special shorthands for combining parsers which will become even\r\nmore useful once parsing begins to return a more structured value than merely\r\nthe matched string. The shorthands are `>>=` for parser products and\r\n`swiperTry(...)` for parser sums. They both work at a different level of\r\nabstraction than the normal `*` and `+` operators.` Here's how they work:\r\n\r\n```swift\r\n// >>= : SResult -> Parser -> SResult\r\n(%\"a\")(\"abc\") >>= %\"b\" == (%\"a\" * %\"b\")(\"abc\")\r\n// swiperTry : (@auto_closure () -> SResult)...\r\nswiperTry( (%\"a\")(\"abc\"), (%\"b\")(\"abc\") ) == (%\"a\" + %\"b\")(\"abc\")\r\n```\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}